We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

<h1>Comentário do texto acima</h1>

**Original**
<p>
  Engenharia de Software, não é apenas programação, e sim também. Ela envolve tempo, escala e trade-offs. Tempo, pois é necessário estipular quanto tempo será usado em determinado requisito, definir prazos de entrega, e como acontecerão as manutenções de código. Escala, pois será necessário definir o tamanho e a complexidade do projeto, além de relacionar-se com a quantidade de recursos, componentes, usuários e a extensão do software. O trade-offs, pois é necessário tomar decisões, referentes a modelagem dos dados, qual tecnologia será usada, qual requisito será acrescentado ou removido e, independente da decisão haverá ganhos e perdas.
</p>

**Corrigido**
<p>
  Engenharia de Software transcende a mera programação, incorporando uma abordagem abrangente que considera fatores cruciais como tempo, escala e trade-offs. A gestão eficaz do tempo é essencial, envolvendo a definição de prazos, a alocação de recursos para requisitos específicos e a estratégia para futuras manutenções do código. Em relação à escala, é imperativo delinear a magnitude e complexidade do projeto, levando em conta recursos, componentes, usuários e a amplitude do software.
</p>

<p>
  Os trade-offs desempenham um papel crucial, exigindo decisões ponderadas em diversas frentes, desde a modelagem de dados até a escolha das tecnologias. A inclusão ou exclusão de requisitos também exige escolhas difíceis, e cada decisão implica ganhos e perdas. Em suma, a Engenharia de Software é um processo multifacetado que vai além da codificação, demandando uma abordagem estratégica para enfrentar os desafios temporais, dimensionais e decisórios inerentes ao desenvolvimento de software.
</p>

<h1>3 exemplos trade-offs</h1>

**a) Banco de dados Relacional e não relacional:**

<p>Não relacional: maior flexibilidade, e escalabilidade. Menos consistência e maior complexidade de consulta.</p>
<p>Relacional: Maior consistência, dificuldade de escalar.</p>

**b) Programar orientado a Objeto x Estruturada:**

<p> Estruturada - maior desempenho. </p>
<p> POO - Execução mais lenta. Facilita a manutenção. O software é reutilizável </p>

**c)On Premise ou Nuvem:**

<p>
  Ao optar por uma infraestrutura On Premise, as organizações desfrutam de controle total sobre seus servidores e dados, garantindo uma maior personalização e segurança. No entanto, esse benefício vem acompanhado de custos elevados de manutenção e a necessidade de investir em hardware robusto.
</p>

<p>
  Já a escolha pela Nuvem oferece flexibilidade, escalabilidade e elimina a responsabilidade direta pela gestão física da infraestrutura. Contudo, pode acarretar em preocupações com a segurança dos dados, dependência de provedores de nuvem e custos recorrentes associados ao uso de recursos na nuvem.
</p>

**EXEMPLOS DE AULA**
d)Windows x Linux
e)Java x Python
j)Usabilidade e Segurança
